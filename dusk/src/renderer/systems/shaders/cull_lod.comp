#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_include : enable
#extension GL_EXT_nonuniform_qualifier : enable

layout (set = 0, binding = 0, std140) uniform GlobalUBO 
{
	mat4 projection;
	mat4 view;
	mat4 inverseView;
	mat4 inverseProjection;

	vec4 frustumPlanes[6];
		
	uint directionalLightsCount;
	uint pointLightsCount;     
	uint spotLightsCount;      
	uint padding;
	
	uvec4 directionalLightIndices[32];
	uvec4 pointLightIndices[32];
	uvec4 spotLightIndices[32];
} globalubo[];

layout(set = 1, binding = 0) buffer meshDataBuffer
{
	uint indexCount;
    uint firstIndex;
    int vertexOffset;
} meshData[];

layout (set = 2, binding = 0, std430) readonly buffer MeshInstanceData 
{
	mat4 modelMatrix;
	mat4 normalMatrix;
	vec3 center;
	uint meshId;
	vec3 extents;
	uint materialId;
} meshInstanceData[];

struct IndexedIndirectCommand 
{
	uint indexCount;
	uint instanceCount;
	uint firstIndex;
	uint vertexOffset;
	uint firstInstance;
};

layout (set = 3, binding = 0, std430) writeonly buffer IndirectDraws
{
	IndexedIndirectCommand indirectDraws[];
} cmdsBuffer;

layout(set = 3, binding = 1, std430) buffer CountOut {
    uint drawCount;
} countBuffer;

layout(push_constant) uniform PushConstant 
{
	uint globalUBOIdx;
	uint objectCount;
} push;

layout (local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

bool isAABBinFrustum(uint meshInstanceIdx)
{
	// this are already in view space
	vec3 center = meshInstanceData[meshInstanceIdx].center;
	vec3 extents = meshInstanceData[meshInstanceIdx].extents;

	// Test AABB against frustum planes
	for (int i = 0; i < 6; ++i)
	{
		vec4 p = globalubo[push.globalUBOIdx].frustumPlanes[i];
		
		float d = dot(vec4(center, 1.0), p);

        float r =
            extents.x * abs(p.x) +
            extents.y * abs(p.y) +
            extents.z * abs(p.z);

        if (d + r < 0.0)
            return false;
	}

	return true;
}

void main()
{
	uint idx = gl_GlobalInvocationID.x;

	// Flattened 2D dispatch to 1D index. Use when we have 2d workgroups
	//uint idx = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * gl_WorkGroupSize.x * gl_NumWorkGroups.x;

	if (idx >= push.objectCount)
		return;

	if (isAABBinFrustum(idx))
	{	
		uint outIdx = atomicAdd(countBuffer.drawCount, 1);

		uint meshId = nonuniformEXT(meshInstanceData[idx].meshId);

		cmdsBuffer.indirectDraws[outIdx].indexCount = meshData[meshId].indexCount;
		cmdsBuffer.indirectDraws[outIdx].instanceCount = 1;
		cmdsBuffer.indirectDraws[outIdx].firstIndex = meshData[meshId].firstIndex;
		cmdsBuffer.indirectDraws[outIdx].vertexOffset = meshData[meshId].vertexOffset;
		cmdsBuffer.indirectDraws[outIdx].firstInstance = idx;
	}
}
