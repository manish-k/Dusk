#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_include : enable
#extension GL_EXT_nonuniform_qualifier : enable

layout (set = 0, binding = 0, std140) uniform GlobalUBO 
{
	mat4 projection;
	mat4 view;
	mat4 inverseView;
	mat4 inverseProjection;

	vec4 frustumPlanes[6];
		
	uint directionalLightsCount;
	uint pointLightsCount;     
	uint spotLightsCount;      
	uint padding;
	
	uvec4 directionalLightIndices[32];
	uvec4 pointLightIndices[32];
	uvec4 spotLightIndices[32];
} globalubo[];

layout (set = 1, binding = 0, std430) readonly buffer MeshInstanceData 
{
	mat4 modelMatrix;
	mat4 normalMatrix;
	vec3 aabbMin;
	uint pad0;
	vec3 aabbMax;
	uint materialId;
	uint indexCount;   
	uint firstIndex;
	uint vertexOffset;
	uint firstInstance;
} meshInstanceData[];

struct IndexedIndirectCommand 
{
	uint indexCount;
	uint instanceCount;
	uint firstIndex;
	uint vertexOffset;
	uint firstInstance;
};

layout (set = 2, binding = 0, std430) writeonly buffer IndirectDraws
{
	IndexedIndirectCommand indirectDraws[];
} cmdsBuffer;

layout(set = 2, binding = 1, std430) buffer CountOut {
    uint drawCount;
} countBuffer;

layout(push_constant) uniform PushConstant 
{
	uint globalUBOIdx;
	uint objectCount;
} push;

layout (local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

bool isAABBinFrustum(uint meshInstanceIdx)
{
	// this are already in view space
	vec3 aabbMin = meshInstanceData[meshInstanceIdx].aabbMin;
	vec3 aabbMax = meshInstanceData[meshInstanceIdx].aabbMax;

	// Test AABB against frustum planes
	for (int i = 0; i < 6; ++i)
	{
		vec4 plane = globalubo[push.globalUBOIdx].frustumPlanes[i];
		
		// Compute the positive vertex
		// For a given plane, pick the AABB corner that is farthest in the direction of the plane normal
		vec3 pVertex;
		pVertex.x = (plane.x >= 0.0) ? aabbMax.x : aabbMin.x;
		pVertex.y = (plane.y >= 0.0) ? aabbMax.y : aabbMin.y;
		pVertex.z = (plane.z >= 0.0) ? aabbMax.z : aabbMin.z;
		
		// If positive vertex is outside the plane, then AABB is outside
		if (dot(plane.xyz, pVertex) + plane.w < 0.0)
		{
			return false;
		}
	}

	return true;
}

void main()
{
	uint idx = gl_GlobalInvocationID.x;

	// Flattened 2D dispatch to 1D index. Use when we have 2d workgroups
	//uint idx = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * gl_WorkGroupSize.x * gl_NumWorkGroups.x;

	if (idx >= push.objectCount)
		return;

	if (isAABBinFrustum(idx))
	{	
		uint outIdx = atomicAdd(countBuffer.drawCount, 1);

		cmdsBuffer.indirectDraws[outIdx].indexCount = meshInstanceData[idx].indexCount;
		cmdsBuffer.indirectDraws[outIdx].instanceCount = 1;
		cmdsBuffer.indirectDraws[outIdx].firstIndex = meshInstanceData[idx].firstIndex;
		cmdsBuffer.indirectDraws[outIdx].vertexOffset = meshInstanceData[idx].vertexOffset;
		cmdsBuffer.indirectDraws[outIdx].firstInstance = meshInstanceData[idx].firstInstance;
	}
}
